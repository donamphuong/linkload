#!/usr/bin/ruby

#include the tuple class
load 'tuple.rb'
require 'date'

#an array that stores tuples that contain information for git commits
$log = Array.new
#a hash that maps a file to tuple that store a commit's information
$map = Hash.new
#the longest word in maps
$longest = 0

#parse the git log command by extracting datetime, SHA1 ID & author
def parse(commits)
  lines = commits.split("\n")
  info = Tuple.new

  #split the string into each line and according to the first word
  #push the respective values into a tuple (commit, author, date)
  lines.each do |w|
    first = w.split.first
    words = w.split.drop(1)
    
    if !words.last.nil? && (words.last.include? "<") 
      words = words.take(words.length - 1)
    end
    next_value = words.join(' ') 

    if first.eql? "commit"
      info.changeCommit(next_value[0..5])
    elsif first.eql? 'Author:'
      info.changeAuthor(next_value)
    elsif first.eql? 'Date:'
      #when there is a time value, push the tuple to the array of commits
      #and make info a new tuple
      info.changeDate(DateTime.parse(next_value))
      $log.push(info)
      info = Tuple.new
    end
  end

  $log.reverse!
end

#traverse through the latest commit and add files into map
#if and only if the file is not already in the list
def add_commit
  $map.each do |k, v|
    $log.each do |l|
      commit = `git show --name-only #{l.getCommit}`
      
      if commit.include? k
        if k.length > $longest
          $longest = k.length
        end
        $map[k] = l
      end
    end
  end
end

#print hash
def print_hash
  $map.each do |key, value|
    if(!(key.nil? || value.nil?))
      puts "#{value.getDate} [#{value.getCommit}]: #{key}" +
            " " * ($longest - key.length) +
            "(#{value.getAuthor})"
    end
  end
end

def traverse(start)
  Dir.foreach(start) do |x|
    path = File.join(start, x)

    if(x == '.' || x == '..')
      next
    elsif File.file?(path) 
      if File.readable?(x)
        $map.store(x, nil)
      end
    else
      traverse(path)
    end
  end
end

if(ARGV.length > 1)
  puts "There can only be one directory"
  exit 1
else
  target_path = ARGV.empty? ? Dir.pwd : ARGV[0]
  traverse(target_path)
  
  commits = `git log`
  parse(commits)
  add_commit
  #puts $length
  print_hash
end
